---
description: Comprehensive local code review script rulebook for KonaAI-API development workflow
globs: ["scripts/*.ps1", "coverlet.runsettings", "CodeReviewAgent/docs/*.md"]
alwaysApply: true
---

# Local Code Review Script Rulebook

## Overview
This rulebook documents the local PowerShell code review script (`scripts/code-review-agent.ps1`) that mirrors the GitHub Actions workflow, providing developers with the same quality gates locally before pushing code.

## Documentation References
- **Complete Guide**: `CodeReviewAgent/docs/LOCAL_SCRIPT_COMPLETE_GUIDE.md` - Comprehensive documentation with visual diagrams, execution modes, and troubleshooting
- **GitHub Workflow Guide**: `CodeReviewAgent/docs/GITHUB_WORKFLOW_COMPLETE_GUIDE.md` - Complete GitHub Actions workflow documentation

## Script Architecture

### 1. Purpose & Design
- **File**: `scripts/code-review-agent.ps1`
- **Purpose**: Pre-push quality gate that runs locally to catch issues before they reach GitHub
- **Mirrors**: GitHub Actions workflow behavior and quality gates
- **Focus**: Controllers & Business logic coverage with 80% threshold
- **Exit Strategy**: Non-zero exit on any failure to block push/PR churn

### 2. Parameters & Options
```powershell
param(
    [switch]$VerboseOutput,    # Enable detailed logging
    [switch]$SkipSecurity,    # Skip security scans
    [switch]$QuickOnly         # Run only quick checks (formatting)
)
```

**Usage Patterns**:
```powershell
# Full local review (mirrors CI)
powershell -ExecutionPolicy Bypass -File scripts/code-review-agent.ps1 -VerboseOutput

# Quick checks only (fast feedback)
powershell -ExecutionPolicy Bypass -File scripts/code-review-agent.ps1 -QuickOnly

# Skip security scans (faster execution)
powershell -ExecutionPolicy Bypass -File scripts/code-review-agent.ps1 -SkipSecurity
```

## Execution Flow & Job Structure

### 1. Job 1: Quick Checks (Fast Feedback)
**Purpose**: Immediate feedback on simple issues
**Duration**: ~30-60 seconds
**Dependencies**: None

#### Steps:
1. **Tool Restoration**
   ```powershell
   dotnet tool restore
   ```
   - **Purpose**: Ensure all .NET tools are available
   - **Error Handling**: Fails if tools cannot be restored
   - **Duration**: ~10-20 seconds

2. **Code Formatting Verification**
   ```powershell
   dotnet format --verify-no-changes $solutionPath
   ```
   - **Purpose**: Verify code formatting compliance
   - **Error Handling**: Fails if formatting issues found
   - **Fix Command**: `dotnet format` to auto-fix issues
   - **Duration**: ~20-40 seconds

#### Quick-Only Mode:
- **Exit Point**: Script exits after quick checks if `-QuickOnly` specified
- **Use Case**: Fast feedback during development
- **Duration**: ~30-60 seconds total

### 2. Job 2: Build and Test (Core Validation)
**Purpose**: Comprehensive validation of code quality and functionality
**Duration**: ~3-5 minutes
**Dependencies**: Quick checks (if not in QuickOnly mode)

#### Build Phase:
```powershell
dotnet build $solutionPath -c Release /warnaserror
```
- **Configuration**: Release mode (production-ready)
- **Quality Enforcement**: Warnings as errors
- **Error Handling**: Fails on any compilation issues
- **Duration**: ~1-2 minutes

#### Test Execution (Parallel Approach):
**Unit Tests**:
```powershell
dotnet test "KonaAI.Master/KonaAI.Master.Test.Unit/KonaAI.Master.Test.Unit.csproj" -c Debug --collect:"XPlat Code Coverage" --settings coverlet.runsettings
```
- **Project**: Unit test project only
- **Configuration**: Debug mode (required for coverage)
- **Coverage**: XPlat Code Coverage with focused settings
- **Duration**: ~1-2 minutes

**Integration Tests**:
```powershell
dotnet test "KonaAI.Master/KonaAI.Master.Test.Integration/KonaAI.Master.Test.Integration.csproj" -c Debug --collect:"XPlat Code Coverage" --settings coverlet.runsettings
```
- **Project**: Integration test project only
- **Configuration**: Debug mode (required for coverage)
- **Coverage**: XPlat Code Coverage with focused settings
- **Duration**: ~1-2 minutes

**Note**: Tests run sequentially in local script (vs parallel in CI) due to PowerShell limitations

### 3. Coverage Analysis & Threshold Enforcement
**Purpose**: Analyze coverage reports and enforce 80% threshold
**Duration**: ~10-30 seconds
**Dependencies**: Both unit and integration tests completed

#### Coverage File Discovery:
```powershell
$unitCoverageFiles = Get-ChildItem -Path "KonaAI.Master" -Recurse -Filter "coverage.cobertura.xml" | Where-Object { $_.FullName -like "*Test.Unit*" }
$integrationCoverageFiles = Get-ChildItem -Path "KonaAI.Master" -Recurse -Filter "coverage.cobertura.xml" | Where-Object { $_.FullName -like "*Test.Integration*" }
```

#### Coverage Parsing:
```powershell
[xml]$unitXml = Get-Content $unitCoverageFiles[0].FullName
$unitCoverage = [double]$unitXml.coverage.'line-rate'
```

#### Threshold Calculation:
```powershell
$combinedCoverage = ($unitCoverage + $integrationCoverage) / 2
$coveragePercent = [math]::Round($combinedCoverage * 100, 2)
```

#### Enforcement Logic:
- **Threshold**: 80% minimum for Controllers & Business logic
- **Focus**: Only measures critical application layers
- **Error Handling**: Fails if below threshold
- **Guidance**: Provides specific recommendations for improvement

### 4. Job 3: Security Scans (Optional)
**Purpose**: Optional security scanning for comprehensive validation
**Duration**: ~1-3 minutes (if tools installed)
**Dependencies**: Build and test completion
**Conditional**: Skipped if `-SkipSecurity` specified

#### Semgrep SAST (Static Analysis):
```powershell
if (Get-Command semgrep -ErrorAction SilentlyContinue) {
    semgrep --config p/ci --error --exclude .git --lang csharp
}
```
- **Purpose**: Static Application Security Testing
- **Language**: C# specific analysis
- **Configuration**: CI-focused security policies
- **Installation**: `pip install semgrep`

#### Gitleaks (Secret Scanning):
```powershell
if (Get-Command gitleaks -ErrorAction SilentlyContinue) {
    gitleaks protect --staged
}
```
- **Purpose**: Secret and credential scanning
- **Scope**: Staged changes only
- **Installation**: Download from GitHub releases

## Error Handling & Logging

### 1. Error Action Preference
```powershell
$ErrorActionPreference = "Stop"
```
- **Behavior**: Script stops on first error
- **Purpose**: Fail-fast approach to catch issues early
- **Consistency**: Matches CI behavior

### 2. Logging Functions
```powershell
function Write-Info($msg) {
    if ($VerboseOutput) { Write-Host "[info] $msg" -ForegroundColor Cyan }
}

function Write-Success($msg) {
    Write-Host "[SUCCESS] $msg" -ForegroundColor Green
}

function Write-Warning($msg) {
    Write-Host "[WARNING] $msg" -ForegroundColor Yellow
}
```

**Logging Levels**:
- **Info**: Detailed progress (only with `-VerboseOutput`)
- **Success**: Successful operations (always shown)
- **Warning**: Non-critical issues (always shown)
- **Error**: Critical failures (always shown, stops execution)

### 3. Try-Catch Error Handling
```powershell
try { 
    dotnet build $solutionPath -c Release /warnaserror
    Write-Success "Build completed successfully"
} catch { 
    Write-Error "Build failed - fix compilation errors" 
}
```

**Error Handling Strategy**:
- **Graceful Degradation**: Continues execution where possible
- **Clear Messages**: Specific error messages with fix suggestions
- **Exit Codes**: Non-zero exit on failures to block push

## Coverage Configuration

### 1. Coverlet Settings
**File**: `coverlet.runsettings`
**Purpose**: Focus coverage measurement on critical layers

```xml
<Include>
  <ModulePath>.*KonaAI\.Master\.(API|Business).*</ModulePath>
</Include>
```

**Included Layers**:
- **Controllers**: API behavior, authentication, validation
- **Business Logic**: Core rules, use cases, business processes

**Excluded Layers**:
- **Repository**: Well-tested via integration tests
- **Models**: DTOs with minimal executable logic

### 2. Coverage Analysis Logic
```powershell
# Calculate combined coverage (weighted average)
$combinedCoverage = ($unitCoverage + $integrationCoverage) / 2
$coveragePercent = [math]::Round($combinedCoverage * 100, 2)
```

**Calculation Method**:
- **Unit Coverage**: From unit test Cobertura XML
- **Integration Coverage**: From integration test Cobertura XML
- **Combined**: Simple average of both coverage percentages
- **Threshold**: 80% minimum for combined coverage

### 3. Threshold Enforcement
```powershell
if ($coveragePercent -lt 80) {
    Write-Error "Coverage below threshold: $coveragePercent% < 80%"
    Write-Host "Focus on adding tests for Controllers and Business logic to reach 80% coverage." -ForegroundColor Yellow
} else {
    Write-Success "Coverage threshold met: $coveragePercent% >= 80%"
}
```

## Performance & Optimization

### 1. Execution Times
- **Quick-Only Mode**: ~30-60 seconds
- **Full Review**: ~3-5 minutes
- **With Security**: ~4-8 minutes (if tools installed)

### 2. Optimization Strategies
- **Sequential Execution**: Tests run one after another (PowerShell limitation)
- **Debug Mode**: Required for coverage collection
- **Focused Coverage**: Only measures critical layers
- **Optional Security**: Can be skipped for faster execution

### 3. Resource Usage
- **CPU**: Moderate during build and test phases
- **Memory**: Standard .NET test execution requirements
- **Disk**: Coverage files and test artifacts
- **Network**: Minimal (only for tool restoration)

## Integration with GitHub Workflow

### 1. Behavior Alignment
- **Same Quality Gates**: Format, build, test, coverage
- **Same Thresholds**: 80% coverage for Controllers & Business logic
- **Same Focus**: Critical application layers only
- **Same Error Handling**: Fail-fast approach

### 2. Coverage Consistency
- **Same Settings**: Uses identical `coverlet.runsettings`
- **Same Calculation**: Combined unit and integration coverage
- **Same Threshold**: 80% minimum requirement
- **Same Focus**: Controllers & Business logic only

### 3. Development Workflow
- **Pre-Push**: Run before pushing to catch issues early
- **Pre-PR**: Run before creating pull requests
- **Local Development**: Quick feedback during coding
- **CI Preparation**: Ensure code will pass CI checks

## Troubleshooting & Maintenance

### 1. Common Issues

#### Coverage Files Not Found
**Issue**: `Coverage files not found. Make sure tests ran successfully.`
**Solutions**:
- Verify tests completed successfully
- Check for test failures in previous steps
- Ensure Debug mode is used for tests
- Verify `coverlet.runsettings` exists

#### Build Failures
**Issue**: `Build failed - fix compilation errors`
**Solutions**:
- Run `dotnet format` to fix formatting issues
- Resolve compilation errors
- Check for missing dependencies
- Verify solution path is correct

#### Test Failures
**Issue**: `Unit tests failed` or `Integration tests failed`
**Solutions**:
- Fix failing tests
- Check test data setup
- Verify test dependencies
- Review test isolation issues

#### Coverage Below Threshold
**Issue**: `Coverage below threshold: X% < 80%`
**Solutions**:
- Add unit tests for Business logic classes
- Add controller unit tests
- Improve integration test coverage
- Focus on Create, Update, Delete operations

### 2. Performance Optimization
- **Use Quick-Only**: For fast feedback during development
- **Skip Security**: For faster execution when security tools not needed
- **Verbose Output**: For detailed debugging information
- **Regular Cleanup**: Remove old coverage files periodically

### 3. Maintenance Tasks
- **Tool Updates**: Keep .NET tools updated
- **Security Tools**: Update Semgrep and Gitleaks regularly
- **Coverage Analysis**: Review coverage trends over time
- **Script Updates**: Keep script aligned with CI workflow changes

## Best Practices

### 1. Development Workflow
- **Pre-Commit**: Run script before committing changes
- **Pre-Push**: Run script before pushing to remote
- **Pre-PR**: Run script before creating pull requests
- **Regular Checks**: Run during development for quick feedback

### 2. Team Collaboration
- **Consistent Usage**: All team members use same script
- **Shared Configuration**: Use same `coverlet.runsettings`
- **Documentation**: Keep script usage documented
- **Training**: Ensure team knows how to use script effectively

### 3. Continuous Improvement
- **Monitor Performance**: Track execution times
- **Coverage Trends**: Monitor coverage improvements
- **Error Patterns**: Track common failure causes
- **Script Evolution**: Update script to match CI improvements

## Exit Codes & Integration

### 1. Exit Code Meanings
- **0**: All checks passed successfully
- **1**: One or more checks failed
- **2**: Script execution error (missing files, tools, etc.)

### 2. Integration Points
- **Git Hooks**: Can be used in pre-push hooks
- **IDE Integration**: Can be run from Visual Studio or VS Code
- **CI Preparation**: Ensures code will pass CI checks
- **Team Standards**: Enforces consistent quality standards

### 3. Automation Opportunities
- **Pre-Push Hook**: Automatically run before push
- **IDE Integration**: Run on save or build
- **Scheduled Runs**: Regular quality checks
- **Team Workflows**: Integrated into development processes

This local code review script provides developers with the same quality gates as the CI pipeline, enabling fast feedback and consistent code quality standards across the team.